# 一些与开发相关的tips

## TCP的三次握手与四次挥手

### 三次握手

1、**第一次握手：**客户端发送请求：客户端向服务器发送一个带有SYN标志位的数据包，同时选择一个初始序列号（ISN），通常是一个随机数。这个序列号用来标识客户端发出的第一个字节。此时，客户端进入SYN_SENT状态。

2、**第二次握手（SYN-ACK）：** 服务器响应：服务器接收到客户端的SYN请求后，会为该连接分配必要的资源，并准备回应。服务器会发送一个包含SYN和ACK确认字符，Acknowledgment）标志位的数据包给客户端。服务器也会选择自己的初始序列号，并用ACK来确认它已经收到了客户端的SYN。此时，服务器进入SYN_RCVD状态。

3、**第三次握手（ACK）：** 客户端确认：客户端接收到服务器的SYN-ACK后，会发送一个ACK数据包作为回应，以确认它已经收到了服务器的SYN。这个ACK包含了对服务器初始序列号的确认，并将自身的序列号增加1。此时，客户端和服务器都进入了ESTABLISHED状态，表示连接已成功建立，可以开始数据传输。

```
客户端                                  服务器
   |                                         |
   |---- SYN, seq=client_isn ---------------->|
   |                                         |
   |<--- SYN, ACK, seq=server_isn, ack=client_isn + 1 ---|
   |                                         |
   |---- ACK, seq=client_isn + 1, ack=server_isn + 1 --->|
   |                                         |
   |                                         |
```

- 客户端发送SYN（同步）包：客户端向服务器发送一个SYN包，表示希望与服务器建立连接。
- 服务器响应SYN-ACK（同步-确认）包：服务器收到SYN包后，会回复一个SYN-ACK包，表示同意建立连接。
- 客户端发送ACK（确认）包：客户端收到SYN-ACK包后，发送一个ACK包给服务器，确认已经收到了服务器的SYN-ACK包

### 四次挥手

1、第一次挥手（FIN）：**主动关闭方发送FIN**：假设客户端是主动关闭方，它会发送一个带有FIN（Finish）标志位的数据包给服务器，表示它已经没有数据要发送了，但仍然可以接收来自服务器的数据。此时，客户端进入FIN_WAIT_1状态。

2、第二次挥手（ACK）：**被动关闭方确认FIN**：服务器接收到客户端的FIN后，会发送一个ACK（确认字符）数据包作为回应，确认它已经收到了客户端的FIN。此时，服务器进入CLOSE_WAIT状态，而客户端进入FIN_WAIT_2状态。

3、第三次挥手（FIN）：**被动关闭方发送FIN**：当服务器也准备好关闭连接时，它会发送自己的FIN数据包给客户端。此时，服务器进入LAST_ACK状态，等待客户端的最终确认。

4、第四次挥手(ACK):**主动关闭方确认FIN**：客户端接收到服务器的FIN后，会发送一个ACK数据包作为最后的确认。此时，客户端进入TIME_WAIT状态，等待足够的时间以确保服务器能够接收到这个ACK（通常为2个最大段生存时间，MSL）。之后，客户端进入CLOSED状态，连接彻底关闭。服务器在接收到ACK后立即进入CLOSED状态。

```
客户端                                  服务器
   |                                         |
   |---- FIN, seq=client_seq ---------------->|
   |                                         |
   |<--- ACK, seq=server_seq, ack=client_seq + 1 ---|
   |                                         |
   |                                         |
   |<--- FIN, seq=server_seq + 1 -------------|
   |                                         |
   |---- ACK, seq=client_seq + 1, ack=server_seq + 2 --->|
   |                                         |
   |                                         |
```

- 客户端发送FIN（结束）包：当客户端完成数据传输后，向服务器发送一个FIN包，表示请求关闭连接。
- 服务器响应ACK（确认）包：服务器收到FIN包后，发送一个ACK包给客户端，表示已收到客户端的关闭请求。
- 服务器发送FIN（结束）包：服务器也完成了数据传输后，向客户端发送一个FIN包，表示请求关闭连接。
- 客户端响应ACK（确认）包：客户端收到服务器的FIN包后，发送一个ACK包给服务器，表示已收到服务器的关闭请求。

-----

## cookie与session

### 什么是cookie？

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

### 什么是Session？

Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。

每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。

### Session和Cookie的区别？

1、数据存储位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、安全性：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。

3、服务器性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。

4、数据大小：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、信息重要程度：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。

------

## redis实现用户状态设置

### 1、使用String实现

给每一个用户分配一个唯一的键，用来存储用户的当前状态。例如：

- 键：user:status:<user_id>
- 值：可以是一个简单的字符串，如"online"、"offline"或"away"。

```java
设置用户状态
SET user:status:123 "online"
获取用户状态
GET user:status:123
```

指定过期时间（适用于临时状态）

```java
SETEX user:last_active:123 3600 "now"  # 状态将在1小时后过期
```

### 2、使用哈希（Hash）数据类型

如果需要存储更多关于用户状态的信息，可以考虑使用哈希表。哈希表允许你在一个键下存储多个字段和值对，非常适合用来表示复杂的状态信息。

- **键**：`user:details:<user_id>`
- **字段**：`status`, `last_active`, `session_id`等

设置多个状态字段

```Java
HSET user:details:123 status "online" last_active "2024-12-03T19:24:00" session_id "abc123"
```

获取单个字段的值

```Java
HGET user:details:123 status
```

获取所有字段和值

```Java
HGETALL user:details:123
```

更新单个字段

```Java
HSET user:details:123 last_active "2024-12-03T19:30:00"
```

### 3、使用集合（Set）或有序集合（Sorted Set）来跟踪在线用户

如果你想要快速获取所有在线用户或者根据某些条件排序用户（例如按最后活跃时间），可以使用集合或有序集合。

- **键**：`users:online`
- **成员**：`<user_id>`

对于有序集合，还可以附加一个分数来表示用户的活跃时间戳或其他指标。

添加用户到在线集合

```Java
SADD users:online 123
```

从在线集合中移除用户

```Java
SREM users:online 123
```

检查用户是否在线

```Java
SISMEMBER users:online 123
```

使用有序集合记录用户活跃时间

```Java
ZADD users:active 1672832400 123  # 假设1672832400是Unix时间戳
```

获取最活跃的前N个用户

```Java
ZREVRANGE users:active 0 9 WITHSCORES  # 获取最活跃的10个
```

### 4、结合Session管理

在Web应用中，通常会结合Session机制来管理用户的状态。你可以将Session ID存储在Redis中，并关联用户的状态信息。这样，每次用户请求时，都可以通过Session ID来查找和更新其状态。

- **键**：`session:<session_id>`
- **值**：包含用户ID和其他状态信息的对象或JSON字符串

创建或更新Session

```Java
SET session:abc123 '{"user_id": 123, "status": "online"}' EX 3600  # Session有效期为1小时
```

根据Session ID获取用户状态

```java
GET session:abc123
```

-----

## 你做过哪些sql优化？

### 优化方法



### 你了解索引？

**什么是索引：**类似于书籍的目录。索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。

**索引原理：** **以空间换时间** 

**常见索引：** 

- 主键索引：列值不能为空（Null）。
- 唯一索引：索引列的值必须唯一，但允许有空值（Null），但只允许有一个空值（Null）。
- 复合索引：一个索引可以包含多个列，多个列共同构成一个复合索引。

#### 索引的优缺点

**优点：**

- 大大提高数据查询速度
- 提高数据检索效率
- 被索引的的列会自动进行排序

**缺点：**

- 索引会占用磁盘空间
- 维护索引需要消耗数据库资源（当对表进行增删改之后需要更新索引文件）

